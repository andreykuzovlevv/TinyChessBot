Hey, our goal is to build a bot, program to play chess variant 'tiny chess'.

We try to do it with solving it.

This variant is just 4x4, it has only 5 pieces on the board for each side initially, all unique, 10 total. Captured pieces can be placed back on the board.

We will try to solve the game using stockfish architechture and game environment algorythm as a reference to make it most optimised.

here is game description: 

TINYHOUSE (Chess.com variant)

Board
- 4×4 grid with coordinates a1–d4 (White at the bottom; ranks increase upward).

Initial setup
- White back rank (a1–d1): K W U F  (King, Wazir, Xiangqi Horse, Ferz)
- Black back rank (a4–d4): F U W K  (Ferz, Xiangqi Horse, Wazir, King)
- Pawns: one per side, placed in front of its own king (White: a2; Black: d3).
- Both reserves start empty.

Piece movement
- King (K): one square in any direction; no castling.
- Pawn (P): one square straight forward; captures one square diagonally forward; no initial two-step; no en passant.
- Wazir (W): one square orthogonally (a (1,0) leaper).
- Ferz (F): one square diagonally (a (1,1) leaper).
- Xiangqi Horse (U): a (2,1) move that is **blockable**: conceptually one orthogonal step followed by one outward diagonal; the first orthogonal square must be empty.

Drops (Crazyhouse rule)
- When you capture an enemy piece, it enters **your reserve**.
- On your turn, you may either move a board piece **or** drop one piece from your reserve onto any empty square.
- **Restriction:** pawns may not be dropped on the last rank.

Promotion
- A pawn that moves to the last rank (rank 4 for White; rank 1 for Black) must promote to **one of** {Ferz, Wazir, Xiangqi Horse}.

End conditions
- **Checkmate**: attacker wins. (Objective stated for the variant.)
- **Stalemate**: the **stalemated player wins**.
- **Threefold repetition**: draw.

Here is what I already have(not decided/final):

src
│   main.cc
│
├───cli
│       cli.cc
│       cli.h
│
├───core
└───solve
        solve.cc
        solve.h

cli.cc
// ----- Usage -----
void print_usage()
{
    std::cout <<
        R"(tinyhouse [solve|play] [options]

Commands:

  solve
    --out <path>   (required) output tablebase file

  play
    --tb <path>    (required) load tablebase file

Examples:
  tinyhouse solve --out tinyhouse.tb
  tinyhouse play --tb tinyhouse.tb
)" << std::endl;
}

solve.h
int solve(const std::string &out_path)
{
    std::cout << "[solve] starting solver...\n";
    std::cout << "output file: " << out_path << "\n";

    std::cout << "[solve] solver not implemented yet.\n";
    return 0;
}


We will get inspired by stockfish repo and implementation, but we dont need certain features.
What features we dont need?
First, we solve it, not implementing search.
Second there is no sliding attacks there.

But right now lets leave implementation of game environment **abstract**(!)
and instead decide what algorythm we going to implement to solve this game.

Lets work on solve.cc?